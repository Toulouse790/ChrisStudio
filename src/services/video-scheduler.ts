import { ScheduledVideo } from '../types/scheduler.js';
import { SchedulerDatabase } from './scheduler-db.js';
import { FullVideoPipeline } from '../workflows/full-video-pipeline.js';
import { YouTubeMetadataGenerator } from './youtube-metadata-generator.js';
import { channels } from '../config/channels.js';
import { readFile } from 'fs/promises';
import { VideoScript } from '../types/index.js';

export class VideoScheduler {
  private db: SchedulerDatabase;
  private pipeline: FullVideoPipeline;
  private metadataGenerator: YouTubeMetadataGenerator;
  private checkInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.db = new SchedulerDatabase();
    this.pipeline = new FullVideoPipeline();
    this.metadataGenerator = new YouTubeMetadataGenerator();
  }

  // Start the scheduler (check every minute)
  start() {
    if (this.checkInterval) return;
    
    console.log('üìÖ Video Scheduler started');
    this.checkInterval = setInterval(() => this.checkSchedule(), 60 * 1000);
    
    // Check immediately on start
    this.checkSchedule();
  }

  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
      console.log('üìÖ Video Scheduler stopped');
    }
  }

  private async checkSchedule() {
    const now = new Date();
    const pendingVideos = await this.db.getVideosByStatus('pending');
    
    for (const video of pendingVideos) {
      // Check if it's time to generate this video
      if (video.scheduledDate <= now) {
        console.log(`üé¨ Starting scheduled generation: ${video.topic}`);
        this.generateScheduledVideo(video);
      }
    }
  }

  private async generateScheduledVideo(video: ScheduledVideo) {
    try {
      // Update status to generating
      await this.db.updateVideo(video.id, { status: 'generating' });
      
      const channel = channels[video.channelId];
      if (!channel) {
        throw new Error(`Channel not found: ${video.channelId}`);
      }
      
      // Generate the video
      const videoPath = await this.pipeline.generateVideo(channel, video.topic);
      
      // Generate optimized YouTube metadata
      console.log('üìä Generating YouTube metadata...');
      const scriptPath = `./output/scripts/${video.channelId}-${Date.now()}.json`;
      
      try {
        const scriptContent = await readFile(scriptPath, 'utf-8');
        const script: VideoScript = JSON.parse(scriptContent);
        
        const metadata = await this.metadataGenerator.generateMetadata(
          script,
          channel.name,
          channel.style.theme
        );
        
        // Get improvement suggestions
        const suggestions = await this.metadataGenerator.suggestImprovements(metadata);
        console.log('üí° SEO Suggestions:');
        suggestions.forEach(s => console.log(`  ${s}`));
        
        // Update with results including metadata
        await this.db.updateVideo(video.id, {
          status: 'ready',
          videoPath,
          scriptPath,
          audioPath: `./output/audio/${video.channelId}-${Date.now()}.mp3`,
          metadata: {
            title: metadata.title,
            description: metadata.description,
            tags: metadata.tags,
            seoScore: metadata.seoScore,
            trendingKeywords: metadata.trendingKeywords
          }
        });
        
        console.log(`‚úÖ Scheduled video ready with SEO score: ${metadata.seoScore}/100`);
        
      } catch (metadataError) {
        console.error('‚ö†Ô∏è Failed to generate metadata, using defaults:', metadataError);
        
        // Fallback to basic metadata
        await this.db.updateVideo(video.id, {
          status: 'ready',
          videoPath,
          scriptPath,
          audioPath: `./output/audio/${video.channelId}-${Date.now()}.mp3`,
          metadata: {
            title: video.topic,
            description: `${video.topic}\n\nGenerated by ${channel.name}`,
            tags: [video.topic.toLowerCase(), channel.style.theme, 'documentary'],
            seoScore: 50,
            trendingKeywords: []
          }
        });
      }
      
    } catch (error: any) {
      console.error(`‚ùå Failed to generate scheduled video:`, error);
      await this.db.updateVideo(video.id, {
        status: 'failed',
        error: error.message
      });
    }
  }

  // Generate schedule for next N weeks
  async generateSchedule(weeksAhead: number = 4) {
    const schedules = await this.db.getSchedules();
    const startDate = new Date();
    startDate.setHours(0, 0, 0, 0);
    
    for (let week = 0; week < weeksAhead; week++) {
      for (const schedule of schedules) {
        if (!schedule.enabled) continue;
        
        // Calculate date for this schedule
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + (week * 7) + schedule.weekday);
        
        const [hours, minutes] = schedule.time.split(':');
        targetDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
        
        // Skip if already passed
        if (targetDate < new Date()) continue;
        
        // Check if already scheduled
        const existing = await this.db.getVideosByDateRange(targetDate, targetDate);
        if (existing.some(v => v.channelId === schedule.channelId)) {
          continue;
        }
        
        // Generate topic based on channel
        const topic = this.generateTopicIdea(schedule.channelId);
        
        // Create scheduled video
        const scheduledVideo: ScheduledVideo = {
          id: `${schedule.channelId}-${targetDate.getTime()}`,
          channelId: schedule.channelId,
          topic,
          scheduledDate: targetDate,
          status: 'pending',
          createdAt: new Date()
        };
        
        await this.db.addVideo(scheduledVideo);
        console.log(`üìÖ Scheduled: ${topic} for ${targetDate.toLocaleString()}`);
      }
    }
  }

  private generateTopicIdea(channelId: string): string {
    const topics = {
      'what-if': [
        'What if humans could photosynthesize like plants?',
        'What if we discovered alien life tomorrow?',
        'What if time travel was invented today?',
        'What if Earth had two moons?',
        'What if we could read minds?',
        'What if humans could fly naturally?',
        'What if the Internet disappeared forever?',
        'What if we found a cure for aging?'
      ],
      'human-odyssey': [
        'The Rise and Fall of the Roman Empire',
        'Ancient Egyptian Engineering Marvels',
        'The Viking Age: Explorers and Warriors',
        'The Silk Road: Connecting East and West',
        'The Renaissance: Birth of Modern Art',
        'The Industrial Revolution and Its Impact',
        'The Space Race: USA vs USSR',
        'The Age of Exploration'
      ],
      'classified-files': [
        'The Mystery of the Bermuda Triangle',
        'Area 51: What Really Happens There?',
        'The Disappearance of Amelia Earhart',
        'The Roswell Incident: UFO or Cover-Up?',
        'The Voynich Manuscript Mystery',
        'DB Cooper: The Perfect Crime?',
        'The Tunguska Event Explained',
        'The Lost City of Atlantis'
      ]
    };
    
    const channelTopics = topics[channelId as keyof typeof topics] || topics['what-if'];
    return channelTopics[Math.floor(Math.random() * channelTopics.length)];
  }

  // Get upcoming schedule
  async getUpcomingVideos(days: number = 30): Promise<ScheduledVideo[]> {
    const end = new Date();
    end.setDate(end.getDate() + days);
    
    return this.db.getVideosByDateRange(new Date(), end);
  }

  // Manually schedule a video
  async scheduleVideo(channelId: string, topic: string, date: Date): Promise<ScheduledVideo> {
    const video: ScheduledVideo = {
      id: `${channelId}-${date.getTime()}-${Date.now()}`,
      channelId,
      topic,
      scheduledDate: date,
      status: 'pending',
      createdAt: new Date()
    };
    
    await this.db.addVideo(video);
    return video;
  }
}
