import { ScheduledVideo } from '../types/scheduler.js';
import { SchedulerDatabase } from './scheduler-db.js';
import { FullVideoPipeline } from '../workflows/full-video-pipeline.js';
import { YouTubeMetadataGenerator } from './youtube-metadata-generator.js';
import { TopicGenerator } from './topic-generator.js';
import { channels } from '../config/channels.js';
import { readFile } from 'fs/promises';
import { VideoScript } from '../types/index.js';
import logger from '../utils/logger.js';

export class VideoScheduler {
  private db: SchedulerDatabase;
  private pipeline: FullVideoPipeline;
  private metadataGenerator: YouTubeMetadataGenerator;
  private topicGenerator: TopicGenerator;
  private checkInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.db = new SchedulerDatabase();
    this.pipeline = new FullVideoPipeline();
    this.metadataGenerator = new YouTubeMetadataGenerator();
    this.topicGenerator = new TopicGenerator();
  }

  // Start the scheduler (check every minute)
  start() {
    if (this.checkInterval) return;
    
    console.log('üìÖ Video Scheduler started');
    this.checkInterval = setInterval(() => this.checkSchedule(), 60 * 1000);
    
    // Check immediately on start
    this.checkSchedule();
  }

  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
      console.log('üìÖ Video Scheduler stopped');
    }
  }

  private async checkSchedule() {
    const now = new Date();
    const pendingVideos = await this.db.getVideosByStatus('pending');
    
    for (const video of pendingVideos) {
      // Check if it's time to generate this video
      if (video.scheduledDate <= now) {
        console.log(`üé¨ Starting scheduled generation: ${video.topic}`);
        this.generateScheduledVideo(video).catch((err) => {
          logger.error({ videoId: video.id, error: (err as Error).message }, 'Unhandled error in scheduled generation');
        });
      }
    }
  }

  private async generateScheduledVideo(video: ScheduledVideo) {
    try {
      // Update status to generating
      await this.db.updateVideo(video.id, { status: 'generating' });
      
      const channel = channels[video.channelId];
      if (!channel) {
        throw new Error(`Channel not found: ${video.channelId}`);
      }
      
      // Generate the video
      const videoPath = await this.pipeline.generateVideo(channel, video.topic);
      
      // Generate optimized YouTube metadata
      console.log('üìä Generating YouTube metadata...');
      const scriptPath = `./output/scripts/${video.channelId}-${Date.now()}.json`;
      
      try {
        const scriptContent = await readFile(scriptPath, 'utf-8');
        const script: VideoScript = JSON.parse(scriptContent);
        
        const metadata = await this.metadataGenerator.generateMetadata(
          script,
          channel.name,
          channel.style.theme
        );
        
        // Get improvement suggestions
        const suggestions = await this.metadataGenerator.suggestImprovements(metadata);
        console.log('üí° SEO Suggestions:');
        suggestions.forEach(s => console.log(`  ${s}`));
        
        // Update with results including metadata
        await this.db.updateVideo(video.id, {
          status: 'ready',
          videoPath,
          scriptPath,
          audioPath: `./output/audio/${video.channelId}-${Date.now()}.mp3`,
          metadata: {
            title: metadata.title,
            description: metadata.description,
            tags: metadata.tags,
            seoScore: metadata.seoScore,
            trendingKeywords: metadata.trendingKeywords
          }
        });
        
        console.log(`‚úÖ Scheduled video ready with SEO score: ${metadata.seoScore}/100`);
        
      } catch (metadataError) {
        console.error('‚ö†Ô∏è Failed to generate metadata, using defaults:', metadataError);
        
        // Fallback to basic metadata
        await this.db.updateVideo(video.id, {
          status: 'ready',
          videoPath,
          scriptPath,
          audioPath: `./output/audio/${video.channelId}-${Date.now()}.mp3`,
          metadata: {
            title: video.topic,
            description: `${video.topic}\n\nGenerated by ${channel.name}`,
            tags: [video.topic.toLowerCase(), channel.style.theme, 'documentary'],
            seoScore: 50,
            trendingKeywords: []
          }
        });
      }
      
    } catch (error: any) {
      console.error(`‚ùå Failed to generate scheduled video:`, error);
      await this.db.updateVideo(video.id, {
        status: 'failed',
        error: error.message
      });
    }
  }

  // Generate schedule for next N weeks
  async generateSchedule(weeksAhead: number = 4) {
    const schedules = await this.db.getSchedules();
    const startDate = new Date();
    startDate.setHours(0, 0, 0, 0);
    
    for (let week = 0; week < weeksAhead; week++) {
      for (const schedule of schedules) {
        if (!schedule.enabled) continue;
        
        // Calculate date for this schedule
        const targetDate = new Date(startDate);
        targetDate.setDate(startDate.getDate() + (week * 7) + schedule.weekday);
        
        const [hours, minutes] = schedule.time.split(':');
        targetDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
        
        // Skip if already passed
        if (targetDate < new Date()) continue;
        
        // Check if already scheduled
        const existing = await this.db.getVideosByDateRange(targetDate, targetDate);
        if (existing.some(v => v.channelId === schedule.channelId)) {
          continue;
        }
        
        // Generate topic using AI
        const channel = channels[schedule.channelId];
        if (!channel) {
          logger.warn({ channelId: schedule.channelId }, 'Channel not found, skipping');
          continue;
        }
        
        // Get previous topics to avoid repetition
        const allVideos = await this.db.getVideos();
        const previousTopics = allVideos
          .filter(v => v.channelId === schedule.channelId)
          .map(v => v.topic);
        
        const topic = await this.topicGenerator.generateTopic(channel, previousTopics);
        logger.info({ channelId: schedule.channelId, topic, date: targetDate }, 'Auto-generated topic');
        
        // Create scheduled video
        const scheduledVideo: ScheduledVideo = {
          id: `${schedule.channelId}-${targetDate.getTime()}`,
          channelId: schedule.channelId,
          topic,
          scheduledDate: targetDate,
          status: 'pending',
          createdAt: new Date()
        };
        
        await this.db.addVideo(scheduledVideo);
        console.log(`üìÖ Scheduled: ${topic} for ${targetDate.toLocaleString()}`);
      }
    }
  }

  /**
   * Generate topic suggestions for a channel
   */
  async generateTopicSuggestions(channelId: string, count: number = 5) {
    const channel = channels[channelId];
    if (!channel) {
      throw new Error(`Channel not found: ${channelId}`);
    }
    
    const allVideos = await this.db.getVideos();
    const previousTopics = allVideos
      .filter(v => v.channelId === channelId)
      .map(v => v.topic);
    
    return this.topicGenerator.generateTopicSuggestions(channel, count, previousTopics);
  }

  // Get upcoming schedule
  async getUpcomingVideos(days: number = 30): Promise<ScheduledVideo[]> {
    const end = new Date();
    end.setDate(end.getDate() + days);
    
    return this.db.getVideosByDateRange(new Date(), end);
  }

  // Manually schedule a video
  async scheduleVideo(channelId: string, topic: string, date: Date): Promise<ScheduledVideo> {
    const video: ScheduledVideo = {
      id: `${channelId}-${date.getTime()}-${Date.now()}`,
      channelId,
      topic,
      scheduledDate: date,
      status: 'pending',
      createdAt: new Date()
    };
    
    await this.db.addVideo(video);
    return video;
  }
}
